import { Random } from "../Utils/Rndm";
export declare class List<T> {
    protected _elements: T[];
    constructor(elements?: T[]);
    Add(element: T): void;
    AddRange(elements: T[]): void;
    Aggregate<U>(accumulator: (accum: U, value?: T, index?: number, list?: T[]) => any, initialValue?: U): any;
    All(predicate: (value?: T, index?: number, list?: T[]) => boolean): boolean;
    Any(predicate: (value?: T, index?: number, list?: T[]) => boolean): boolean;
    Average(): number;
    Average(transform: (value?: T, index?: number, list?: T[]) => any): number;
    Concat(list: List<T>): List<T>;
    Contains(element: T): boolean;
    Count(): number;
    Count(predicate: (value?: T, index?: number, list?: T[]) => boolean): number;
    DefaultIfEmpty(defaultValue?: T): List<T>;
    Distinct(): List<T>;
    ElementAt(index: number): T;
    ElementAtOrDefault(index: number): T;
    Except(source: List<T>): List<T>;
    First(): T;
    First(predicate: (value?: T, index?: number, list?: T[]) => boolean): T;
    FirstOrDefault(): T;
    FirstOrDefault(predicate: (value?: T, index?: number, list?: T[]) => boolean): T;
    ForEach(action: (value?: T, index?: number, list?: T[]) => any): void;
    GroupBy(grouper: (key: T) => any, mapper: (element: T) => any): any;
    GroupJoin<U>(list: List<U>, key1: (k: T) => any, key2: (k: U) => any, result: (first: T, second: List<U>) => any): List<any>;
    IndexOf(element: T): number;
    Insert(index: number, element: T): void;
    Intersect(source: List<T>): List<T>;
    Join<U>(list: List<U>, key1: (key: T) => any, key2: (key: U) => any, result: (first: T, second: U) => any): List<any>;
    Last(): T;
    Last(predicate: (value?: T, index?: number, list?: T[]) => boolean): T;
    LastOrDefault(): T;
    LastOrDefault(predicate: (value?: T, index?: number, list?: T[]) => boolean): T;
    Max(): T;
    Min(): T;
    OrderBy(keySelector: (key: T) => any): List<T>;
    OrderByDescending(keySelector: (key: T) => any): List<T>;
    ThenBy(keySelector: (key: T) => any): List<T>;
    ThenByDescending(keySelector: (key: T) => any): List<T>;
    Remove(element: T): boolean;
    RemoveAll(predicate: (value?: T, index?: number, list?: T[]) => boolean): List<T>;
    RemoveAt(index: number): void;
    Reverse(): List<T>;
    Select(mapper: (value?: T, index?: number, list?: T[]) => any): List<any>;
    SelectMany(mapper: (value?: T, index?: number, list?: T[]) => any): List<any>;
    SequenceEqual(list: List<T>): boolean;
    Single(): T | TypeError;
    SingleOrDefault(): T | TypeError;
    Skip(amount: number): List<T>;
    SkipWhile(predicate: (value?: T, index?: number, list?: T[]) => boolean): List<T>;
    Sum(): number;
    Sum(transform: (value?: T, index?: number, list?: T[]) => number): number;
    Take(amount: number): List<T>;
    TakeWhile(predicate: (value?: T, index?: number, list?: T[]) => boolean): List<T>;
    ToArray(): T[];
    ToDictionary<TKey, TValue>(key: (key: any) => TKey, value?: (value: any) => TValue): any;
    ToList(): List<T>;
    ToLookup(keySelector: (key: T) => any, elementSelector: (element: T) => any): any;
    Union(list: List<T>): List<T>;
    Where(predicate: (value?: T, index?: number, list?: T[]) => boolean): List<T>;
    Zip<U>(list: List<U>, result: (first: T, second: U) => any): List<any>;
    Shuffle(random: Random): void;
    private _negate;
}
export declare class Enumerable {
    static Range(start: number, count: number): List<number>;
    static Repeat<T>(element: T, count: number): List<T>;
}

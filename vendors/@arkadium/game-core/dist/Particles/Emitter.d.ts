/// <reference types="pixi.js" />
import { Color, SimpleEase } from "./ParticleUtils";
import { Particle } from "./Particle";
import { PropertyNode } from "./PropertyNode";
import { PolygonalChain } from "./PolygonalChain";
import { EmitterConfig, OldEmitterConfig } from "./EmitterConfig";
export interface ParticleConstructor {
    new (emitter: Emitter): Particle;
}
export declare class Emitter {
    protected _particleConstructor: typeof Particle;
    particleImages: any[];
    startAlpha: PropertyNode<number>;
    startSpeed: PropertyNode<number>;
    minimumSpeedMultiplier: number;
    acceleration: PIXI.Point;
    maxSpeed: number;
    startScale: PropertyNode<number>;
    minimumScaleMultiplier: number;
    startColor: PropertyNode<Color>;
    minLifetime: number;
    maxLifetime: number;
    minStartRotation: number;
    maxStartRotation: number;
    noRotation: boolean;
    minRotationSpeed: number;
    maxRotationSpeed: number;
    rotationAcceleration: number;
    particleBlendMode: number;
    customEase: SimpleEase;
    extraData: any;
    protected _frequency: number;
    spawnChance: number;
    maxParticles: number;
    emitterLifetime: number;
    spawnPos: PIXI.Point;
    spawnType: string;
    protected _spawnFunc: (p: Particle, emitPosX: number, emitPosY: number, i?: number) => void;
    spawnRect: PIXI.Rectangle;
    spawnPolygonalChain: PolygonalChain;
    spawnCircle: PIXI.Circle & {
        minRadius: number;
    };
    particlesPerWave: number;
    particleSpacing: number;
    angleStart: number;
    protected rotation: number;
    protected ownerPos: PIXI.Point;
    protected _prevEmitterPos: PIXI.Point;
    protected _prevPosIsValid: boolean;
    protected _posChanged: boolean;
    protected _parent: PIXI.Container;
    addAtBack: boolean;
    particleCount: number;
    protected _emit: boolean;
    protected _spawnTimer: number;
    protected _emitterLife: number;
    protected _activeParticlesFirst: Particle;
    protected _activeParticlesLast: Particle;
    protected _poolFirst: Particle;
    protected _origConfig: any;
    protected _origArt: any;
    protected _autoUpdate: boolean;
    protected _currentImageIndex: number;
    protected _destroyWhenComplete: boolean;
    protected _completeCallback: () => void;
    constructor(particleParent: PIXI.Container, particleImages: any, config: EmitterConfig | OldEmitterConfig);
    get orderedArt(): boolean;
    set orderedArt(value: boolean);
    get frequency(): number;
    set frequency(value: number);
    get particleConstructor(): typeof Particle;
    set particleConstructor(value: typeof Particle);
    get parent(): PIXI.Container;
    set parent(value: PIXI.Container);
    init(art: any, config: EmitterConfig | OldEmitterConfig): void;
    protected initAdditional(art: any, config: EmitterConfig | OldEmitterConfig): void;
    protected parseSpawnType(config: EmitterConfig | OldEmitterConfig): void;
    recycle(particle: Particle): void;
    rotate(newRot: number): void;
    updateSpawnPos(x: number, y: number): void;
    updateOwnerPos(x: number, y: number): void;
    resetPositionTracking(): void;
    get emit(): boolean;
    set emit(value: boolean);
    get autoUpdate(): boolean;
    set autoUpdate(value: boolean);
    playOnceAndDestroy(callback?: () => void): void;
    playOnce(callback?: () => void): void;
    update(delta: number): void;
    protected applyAdditionalProperties(p: Particle): void;
    protected _spawnPoint(p: Particle, emitPosX: number, emitPosY: number): void;
    protected _spawnRect(p: Particle, emitPosX: number, emitPosY: number): void;
    protected _spawnCircle(p: Particle, emitPosX: number, emitPosY: number): void;
    protected _spawnRing(p: Particle, emitPosX: number, emitPosY: number): void;
    protected _spawnPolygonalChain(p: Particle, emitPosX: number, emitPosY: number): void;
    protected _spawnBurst(p: Particle, emitPosX: number, emitPosY: number, i: number): void;
    cleanup(): void;
    destroy(): void;
}
